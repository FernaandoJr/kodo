import {
	app,
	BrowserWindow,
	desktopCapturer,
	dialog,
	ipcMain,
	Menu,
	nativeImage,
	Notification,
	shell,
	Tray,
} from "electron"
import * as fs from "fs"
import * as path from "path"
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
	app.quit()
}

let tray: Tray | null = null
let mainWindow: BrowserWindow | null = null
let isRecording = false

// Create a simple icon using nativeImage
const createTrayIcon = (isRecording: boolean): Electron.NativeImage => {
	// Create a 16x16 icon with a simple design
	const size = 16

	if (isRecording) {
		// Red circle icon for recording
		const canvas = Buffer.alloc(size * size * 4)
		for (let y = 0; y < size; y++) {
			for (let x = 0; x < size; x++) {
				const idx = (y * size + x) * 4
				const dx = x - size / 2
				const dy = y - size / 2
				const dist = Math.sqrt(dx * dx + dy * dy)

				if (dist < size / 2 - 1) {
					canvas[idx] = 255 // R
					canvas[idx + 1] = 0 // G
					canvas[idx + 2] = 0 // B
					canvas[idx + 3] = 255 // A
				} else {
					canvas[idx] = 0
					canvas[idx + 1] = 0
					canvas[idx + 2] = 0
					canvas[idx + 3] = 0
				}
			}
		}
		return nativeImage.createFromBuffer(canvas, {
			width: size,
			height: size,
		})
	} else {
		// Gray circle icon for idle
		const canvas = Buffer.alloc(size * size * 4)
		for (let y = 0; y < size; y++) {
			for (let x = 0; x < size; x++) {
				const idx = (y * size + x) * 4
				const dx = x - size / 2
				const dy = y - size / 2
				const dist = Math.sqrt(dx * dx + dy * dy)

				if (dist < size / 2 - 1) {
					canvas[idx] = 128 // R
					canvas[idx + 1] = 128 // G
					canvas[idx + 2] = 128 // B
					canvas[idx + 3] = 255 // A
				} else {
					canvas[idx] = 0
					canvas[idx + 1] = 0
					canvas[idx + 2] = 0
					canvas[idx + 3] = 0
				}
			}
		}
		return nativeImage.createFromBuffer(canvas, {
			width: size,
			height: size,
		})
	}
}

const createTray = (): void => {
	const icon = createTrayIcon(false)
	tray = new Tray(icon)

	const contextMenu = Menu.buildFromTemplate([
		{
			label: isRecording ? "Gravando..." : "Kodo",
			enabled: false,
		},
		{ type: "separator" },
		{
			label: "Mostrar Janela",
			click: () => {
				if (mainWindow) {
					mainWindow.show()
					mainWindow.focus()
				}
			},
		},
		{
			label: "Sair",
			click: () => {
				app.quit()
			},
		},
	])

	tray.setToolTip("Kodo")
	tray.setContextMenu(contextMenu)

	tray.on("click", () => {
		if (mainWindow) {
			if (mainWindow.isVisible()) {
				mainWindow.hide()
			} else {
				mainWindow.show()
				mainWindow.focus()
			}
		}
	})
}

const updateTrayIcon = (recording: boolean): void => {
	if (!tray) return
	isRecording = recording
	const icon = createTrayIcon(recording)
	tray.setImage(icon)

	// Update context menu
	const contextMenu = Menu.buildFromTemplate([
		{
			label: recording ? "Gravando..." : "Kodo",
			enabled: false,
		},
		{ type: "separator" },
		{
			label: "Mostrar Janela",
			click: () => {
				if (mainWindow) {
					mainWindow.show()
					mainWindow.focus()
				}
			},
		},
		{
			label: "Sair",
			click: () => {
				app.quit()
			},
		},
	])
	tray.setContextMenu(contextMenu)
	tray.setToolTip(recording ? "Kodo - Gravando" : "Kodo")
}

// Register IPC handlers before app is ready
// This ensures handlers are available when the renderer process starts
ipcMain.handle("get-desktop-sources", async (event, options) => {
	try {
		console.log("[Main] Getting desktop sources with options:", options)
		const sources = await desktopCapturer.getSources(options)
		console.log("[Main] Found", sources.length, "sources")
		return sources
	} catch (error) {
		console.error("[Main] Error getting desktop sources:", error)
		throw error
	}
})

ipcMain.on("recording-state-changed", (event, recording: boolean) => {
	updateTrayIcon(recording)
})

ipcMain.handle(
	"save-recording",
	async (event, buffer: Uint8Array, mimeType: string) => {
		try {
			// Determine file extension from mime type
			const extension = mimeType.includes("webm") ? "webm" : "webm"

			// Request save dialog
			const { filePath, canceled } = await dialog.showSaveDialog(
				mainWindow || undefined,
				{
					title: "Salvar Gravação",
					defaultPath: `recording-${Date.now()}.${extension}`,
					filters: [
						{ name: "Vídeo WebM", extensions: ["webm"] },
						{ name: "Todos os Arquivos", extensions: ["*"] },
					],
				}
			)

			if (canceled || !filePath) {
				return { success: false, message: "Salvamento cancelado" }
			}

			// Write file
			fs.writeFileSync(filePath, Buffer.from(buffer))

			// Show notification
			const fileName = path.basename(filePath)
			const notification = new Notification({
				title: "Gravação Salva",
				body: `Arquivo salvo: ${fileName}`,
				icon: createTrayIcon(false), // Use tray icon as notification icon
			})

			notification.on("click", () => {
				// Show file in folder
				if (mainWindow) {
					mainWindow.show()
					mainWindow.focus()
				}
				// Open folder (platform-specific)
				shell.showItemInFolder(filePath)
			})

			notification.show()

			return { success: true, filePath, fileName }
		} catch (error) {
			console.error("[Main] Error saving recording:", error)
			return {
				success: false,
				message:
					error instanceof Error
						? error.message
						: "Erro ao salvar arquivo",
			}
		}
	}
)

const createWindow = (): void => {
	// Create the browser window.
	mainWindow = new BrowserWindow({
		height: 900,
		width: 1400,
		minHeight: 600,
		minWidth: 1000,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
			nodeIntegration: false,
			contextIsolation: true,
		},
	})

	// and load the index.html of the app.
	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

	// Open the DevTools in development
	if (process.env.NODE_ENV === "development") {
		mainWindow.webContents.openDevTools()
	}

	// Hide window on close instead of quitting (minimize to tray)
	mainWindow.on("close", (event) => {
		if (!appIsQuitting) {
			event.preventDefault()
			mainWindow?.hide()
		}
	})
}

// Prevent default quit behavior
let appIsQuitting = false
app.on("before-quit", () => {
	appIsQuitting = true
})

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", () => {
	createWindow()
	createTray()

	// Request notification permission (Windows 10+)
	if (process.platform === "win32") {
		// Windows 10+ requires notification permission
		// This is handled automatically by Electron, but we can check
		if (Notification.isSupported()) {
			console.log("[Main] Notifications are supported")
		}
	}

	// Hide dock icon on macOS (only available on macOS)
	if (process.platform === "darwin" && app.dock) {
		app.dock.hide()
	}
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
	// Don't quit, keep running in system tray
	// On macOS, keep the app running even when all windows are closed
	if (process.platform !== "darwin") {
		// On Windows/Linux, the app will stay in system tray
		// The window close handler will hide the window instead of quitting
	}
})

app.on("activate", () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow()
	} else if (mainWindow) {
		mainWindow.show()
		mainWindow.focus()
	}
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
