import {
	app,
	BrowserWindow,
	desktopCapturer,
	dialog,
	globalShortcut,
	ipcMain,
	Menu,
	nativeImage,
	Notification,
	shell,
	Tray,
} from "electron"
import * as fs from "fs"
import * as path from "path"

// Shortcuts configuration
interface ShortcutConfig {
	action: string
	accelerator: string
	description: string
}

interface ShortcutsSettings {
	shortcuts: ShortcutConfig[]
}

const DEFAULT_SHORTCUTS: ShortcutConfig[] = [
	{
		action: "toggle-recording",
		accelerator: "CommandOrControl+Shift+R",
		description: "Iniciar/Parar GravaÃ§Ã£o",
	},
	{
		action: "toggle-window",
		accelerator: "CommandOrControl+Shift+K",
		description: "Mostrar/Esconder Janela",
	},
]

let currentShortcuts: ShortcutConfig[] = []

// File system helpers
const getShortcutsFilePath = (): string => {
	return path.join(app.getPath("userData"), "shortcuts.json")
}

const loadShortcuts = (): ShortcutConfig[] => {
	try {
		const filePath = getShortcutsFilePath()
		if (fs.existsSync(filePath)) {
			const data = fs.readFileSync(filePath, "utf-8")
			const settings: ShortcutsSettings = JSON.parse(data)
			console.log("[Main] Shortcuts loaded successfully")
			return settings.shortcuts
		}
		console.log("[Main] No shortcuts file found, using defaults")
	} catch (error) {
		console.error("[Main] Error loading shortcuts:", error)
	}
	return [...DEFAULT_SHORTCUTS]
}

const saveShortcuts = (shortcuts: ShortcutConfig[]): boolean => {
	try {
		const filePath = getShortcutsFilePath()
		const settings: ShortcutsSettings = { shortcuts }
		fs.writeFileSync(filePath, JSON.stringify(settings, null, 2))
		console.log("[Main] Shortcuts saved successfully")
		return true
	} catch (error) {
		console.error("[Main] Error saving shortcuts:", error)
		return false
	}
}

const executeShortcutAction = (action: string): void => {
	console.log("[Main] Executing shortcut action:", action)

	switch (action) {
		case "toggle-recording":
			if (mainWindow) {
				mainWindow.webContents.send("shortcut-triggered", action)
			}
			break
		case "toggle-window":
			if (mainWindow) {
				if (mainWindow.isVisible()) {
					mainWindow.hide()
				} else {
					mainWindow.show()
					mainWindow.focus()
				}
			}
			break
		default:
			console.log("[Main] Unknown action:", action)
	}
}

const registerShortcuts = (): void => {
	// Unregister all existing shortcuts first
	globalShortcut.unregisterAll()

	currentShortcuts = loadShortcuts()

	for (const shortcut of currentShortcuts) {
		try {
			const success = globalShortcut.register(
				shortcut.accelerator,
				() => {
					executeShortcutAction(shortcut.action)
				}
			)

			if (success) {
				console.log(
					`[Main] Registered shortcut: ${shortcut.accelerator} -> ${shortcut.action}`
				)
			} else {
				console.error(
					`[Main] Failed to register shortcut: ${shortcut.accelerator}`
				)
			}
		} catch (error) {
			console.error(
				`[Main] Error registering shortcut ${shortcut.accelerator}:`,
				error
			)
		}
	}
}

const unregisterShortcuts = (): void => {
	globalShortcut.unregisterAll()
	console.log("[Main] All shortcuts unregistered")
}
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
	app.quit()
}

let tray: Tray | null = null
let mainWindow: BrowserWindow | null = null

// Get the app icon path (for window and notifications)
const getAppIconPath = (): string => {
	return app.isPackaged
		? path.join(process.resourcesPath, "icon.png")
		: path.join(__dirname, "../../src/assets/icon.png")
}

// Get tray icon path based on recording state
const getTrayIconPath = (isRecording: boolean): string => {
	const iconName = isRecording ? "tray_recording.png" : "tray.png"
	return app.isPackaged
		? path.join(process.resourcesPath, iconName)
		: path.join(__dirname, "../../src/assets/" + iconName)
}

// Create tray icon from files
const createTrayIcon = (isRecording: boolean): Electron.NativeImage => {
	const iconPath = getTrayIconPath(isRecording)

	try {
		const icon = nativeImage.createFromPath(iconPath)

		if (icon.isEmpty()) {
			console.error("[Main] Tray icon not found:", iconPath)
			return createFallbackIcon(isRecording)
		}

		// Resize to standard tray size (16x16 for Windows)
		return icon.resize({ width: 16, height: 16, quality: "best" })
	} catch (error) {
		console.error("[Main] Error loading tray icon:", error)
		return createFallbackIcon(isRecording)
	}
}

// Fallback icon if files can't be loaded
const createFallbackIcon = (isRecording: boolean): Electron.NativeImage => {
	const size = 16
	const canvas = Buffer.alloc(size * size * 4)
	const color = isRecording
		? { r: 255, g: 60, b: 60 }
		: { r: 200, g: 200, b: 200 }

	for (let y = 0; y < size; y++) {
		for (let x = 0; x < size; x++) {
			const idx = (y * size + x) * 4
			const dx = x - 8
			const dy = y - 8
			const dist = Math.sqrt(dx * dx + dy * dy)

			if (dist < 7) {
				canvas[idx] = color.r
				canvas[idx + 1] = color.g
				canvas[idx + 2] = color.b
				canvas[idx + 3] = 255
			}
		}
	}

	return nativeImage.createFromBuffer(canvas, { width: size, height: size })
}

const createTray = (): void => {
	const icon = createTrayIcon(false)
	tray = new Tray(icon)

	const contextMenu = Menu.buildFromTemplate([
		{
			label: "Kodo",
			enabled: false,
		},
		{ type: "separator" },
		{
			label: "âº Iniciar GravaÃ§Ã£o",
			click: () => {
				if (mainWindow) {
					mainWindow.webContents.send(
						"shortcut-triggered",
						"toggle-recording"
					)
				}
			},
		},
		{ type: "separator" },
		{
			label: "Mostrar Janela",
			click: () => {
				if (mainWindow) {
					mainWindow.show()
					mainWindow.focus()
				}
			},
		},
		{
			label: "Sair",
			click: () => {
				app.quit()
			},
		},
	])

	tray.setToolTip("Kodo")
	tray.setContextMenu(contextMenu)

	tray.on("click", () => {
		if (mainWindow) {
			if (mainWindow.isVisible()) {
				mainWindow.hide()
			} else {
				mainWindow.show()
				mainWindow.focus()
			}
		}
	})
}

const updateTrayIcon = (recording: boolean): void => {
	if (!tray) return
	const icon = createTrayIcon(recording)
	tray.setImage(icon)

	// Update context menu
	const contextMenu = Menu.buildFromTemplate([
		{
			label: recording ? "ðŸ”´ Gravando..." : "Kodo",
			enabled: false,
		},
		{ type: "separator" },
		{
			label: recording ? "â¹ Parar GravaÃ§Ã£o" : "âº Iniciar GravaÃ§Ã£o",
			click: () => {
				if (mainWindow) {
					mainWindow.webContents.send(
						"shortcut-triggered",
						"toggle-recording"
					)
				}
			},
		},
		{ type: "separator" },
		{
			label: "Mostrar Janela",
			click: () => {
				if (mainWindow) {
					mainWindow.show()
					mainWindow.focus()
				}
			},
		},
		{
			label: "Sair",
			click: () => {
				app.quit()
			},
		},
	])
	tray.setContextMenu(contextMenu)
	tray.setToolTip(recording ? "Kodo - Gravando" : "Kodo")
}

// Register IPC handlers before app is ready
// This ensures handlers are available when the renderer process starts
ipcMain.handle("get-desktop-sources", async (event, options) => {
	try {
		console.log("[Main] Getting desktop sources with options:", options)
		const sources = await desktopCapturer.getSources(options)
		console.log("[Main] Found", sources.length, "sources")
		return sources
	} catch (error) {
		console.error("[Main] Error getting desktop sources:", error)
		throw error
	}
})

ipcMain.on("recording-state-changed", (event, recording: boolean) => {
	updateTrayIcon(recording)
})

// Shortcuts IPC handlers
ipcMain.handle("get-shortcuts", async () => {
	return currentShortcuts.length > 0 ? currentShortcuts : loadShortcuts()
})

ipcMain.handle("get-default-shortcuts", async () => {
	return DEFAULT_SHORTCUTS
})

ipcMain.handle(
	"update-shortcut",
	async (event, action: string, accelerator: string) => {
		try {
			const shortcuts = loadShortcuts()
			const index = shortcuts.findIndex((s) => s.action === action)

			if (index !== -1) {
				shortcuts[index].accelerator = accelerator
				saveShortcuts(shortcuts)
				registerShortcuts()
				return { success: true }
			}

			return { success: false, message: "Atalho nÃ£o encontrado" }
		} catch (error) {
			console.error("[Main] Error updating shortcut:", error)
			return {
				success: false,
				message:
					error instanceof Error
						? error.message
						: "Erro ao atualizar atalho",
			}
		}
	}
)

ipcMain.handle("reset-shortcuts", async () => {
	try {
		saveShortcuts([...DEFAULT_SHORTCUTS])
		registerShortcuts()
		return { success: true, shortcuts: DEFAULT_SHORTCUTS }
	} catch (error) {
		console.error("[Main] Error resetting shortcuts:", error)
		return {
			success: false,
			message:
				error instanceof Error
					? error.message
					: "Erro ao restaurar atalhos",
		}
	}
})

// Window control IPC handlers
ipcMain.on("window-minimize", () => {
	mainWindow?.minimize()
})

ipcMain.on("window-maximize", () => {
	if (mainWindow?.isMaximized()) {
		mainWindow.unmaximize()
	} else {
		mainWindow?.maximize()
	}
})

ipcMain.on("window-close", () => {
	mainWindow?.close()
})

ipcMain.handle("window-is-maximized", () => {
	return mainWindow?.isMaximized() ?? false
})

ipcMain.handle(
	"save-recording",
	async (event, buffer: Uint8Array, mimeType: string) => {
		try {
			// Determine file extension from mime type
			const extension = mimeType.includes("webm") ? "webm" : "webm"

			// Request save dialog
			const { filePath, canceled } = await dialog.showSaveDialog(
				mainWindow || undefined,
				{
					title: "Salvar GravaÃ§Ã£o",
					defaultPath: `recording-${Date.now()}.${extension}`,
					filters: [
						{ name: "VÃ­deo WebM", extensions: ["webm"] },
						{ name: "Todos os Arquivos", extensions: ["*"] },
					],
				}
			)

			if (canceled || !filePath) {
				return { success: false, message: "Salvamento cancelado" }
			}

			// Write file
			fs.writeFileSync(filePath, Buffer.from(buffer))

			// Show notification
			const fileName = path.basename(filePath)
			const notification = new Notification({
				title: "GravaÃ§Ã£o Salva",
				body: `Arquivo salvo: ${fileName}`,
				icon: getAppIconPath(),
			})

			notification.on("click", () => {
				// Show file in folder
				if (mainWindow) {
					mainWindow.show()
					mainWindow.focus()
				}
				// Open folder (platform-specific)
				shell.showItemInFolder(filePath)
			})

			notification.show()

			return { success: true, filePath, fileName }
		} catch (error) {
			console.error("[Main] Error saving recording:", error)
			return {
				success: false,
				message:
					error instanceof Error
						? error.message
						: "Erro ao salvar arquivo",
			}
		}
	}
)

const createWindow = (): void => {
	// Create the browser window.
	mainWindow = new BrowserWindow({
		height: 900,
		width: 1400,
		minHeight: 600,
		minWidth: 1000,
		frame: false,
		titleBarStyle: "hidden",
		autoHideMenuBar: true,
		icon: app.isPackaged
			? path.join(process.resourcesPath, "icon.png")
			: path.join(__dirname, "../../src/assets/icon.png"),
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
			nodeIntegration: false,
			contextIsolation: true,
		},
	})

	// Remove the default menu bar
	Menu.setApplicationMenu(null)

	// and load the index.html of the app.
	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

	// Hide window on close instead of quitting (minimize to tray)
	mainWindow.on("close", (event) => {
		if (!appIsQuitting) {
			event.preventDefault()
			mainWindow?.hide()
		}
	})

	// Notify renderer about window state changes
	mainWindow.on("maximize", () => {
		mainWindow?.webContents.send("window-maximized", true)
	})

	mainWindow.on("unmaximize", () => {
		mainWindow?.webContents.send("window-maximized", false)
	})
}

// Prevent default quit behavior
let appIsQuitting = false
app.on("before-quit", () => {
	appIsQuitting = true
})

app.on("will-quit", () => {
	unregisterShortcuts()
})

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", () => {
	createWindow()
	createTray()
	registerShortcuts()

	// Request notification permission (Windows 10+)
	if (process.platform === "win32") {
		// Windows 10+ requires notification permission
		// This is handled automatically by Electron, but we can check
		if (Notification.isSupported()) {
			console.log("[Main] Notifications are supported")
		}
	}

	// Hide dock icon on macOS (only available on macOS)
	if (process.platform === "darwin" && app.dock) {
		app.dock.hide()
	}
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
	// Don't quit, keep running in system tray
	// On macOS, keep the app running even when all windows are closed
	if (process.platform !== "darwin") {
		// On Windows/Linux, the app will stay in system tray
		// The window close handler will hide the window instead of quitting
	}
})

app.on("activate", () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow()
	} else if (mainWindow) {
		mainWindow.show()
		mainWindow.focus()
	}
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
